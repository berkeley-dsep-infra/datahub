etcJupyter:
  jupyter_notebook_config.json:
    # if a user leaves a notebook with a running kernel,
    # the effective idle timeout will typically be CULL_TIMEOUT + CULL_KERNEL_TIMEOUT
    # as culling the kernel will register activity,
    # resetting the no_activity timer for the server as a whole
    MappingKernelManager:
      # shutdown kernels after no activity
      cull_idle_timeout: 3600
      # check for idle kernels this often
      cull_interval: 300
      # a kernel with open connections but no activity still counts as idle
      # this is what allows us to shutdown servers
      # when people leave a notebook open and wander off
      cull_connected: true

nfsMounter:
  enabled: true

nfsPVC:
  enabled: false
jupyterhub:
  scheduling:
    podPriority:
      enabled: true
      globalDefault: false
      defaultPriority: 0
      userPlaceholderPriority: -10
    userScheduler:
      enabled: true
      resources:
        requests:
          memory: 64Mi
        limits:
          memory: 512Mi
  proxy:
    chp:
      resources:
        requests:
          memory: 320Mi
        limits:
          memory: 320Mi
    nginx:
      resources:
        requests:
          memory: 512Mi
        limits:
          memory: 512Mi
    https:
      letsencrypt:
        contactEmail: yuvipanda@berkeley.edu
    networkPolicy:
      enabled: true
  singleuser:
    defaultUrl: /tree
    networkPolicy:
      # In clusters with NetworkPolicy enabled, do not
      # allow outbound internet access that's not DNS, HTTP or HTTPS
      # We can override this on a case to case basesi where
      # required.
      enabled: true
      egress:
        - ports:
            - port: 53
              protocol: UDP
        - ports:
            - port: 80
              protocol: TCP
        - ports:
            - port: 443
              protocol: TCP
  auth:
    google:
      hostedDomain: [berkeley.edu]
    # common settings when using Canvas Auth
    # Enabled by setting 'custom' as auth.type in individual hub config
    custom:
      className: canvasauthenticator.CanvasAuthenticator
      config:
        canvas_url: https://bcourses.berkeley.edu/
        strip_email_domain: berkeley.edu
        login_service: bCourses
        scope:
          - url:GET|/api/v1/users/:user_id/profile
          - url:GET|/api/v1/courses
        username_key: primary_email
  hub:
    # Generated by chartpress
    image:
      name: gcr.io/ucb-datahub-2018/jupyterhub-hub
      tag: 13fa329
    networkPolicy:
      enabled: true
    resources:
      requests:
        memory: 256Mi
      limits:
        memory: 1Gi
    extraEnv:
      # This is unfortunately still needed by canvas auth
      OAUTH2_AUTHORIZE_URL: https://bcourses.berkeley.edu/login/oauth2/auth
    extraConfig:
      01-custom-attr-spawner: |
        import os
        from functools import lru_cache

        from kubespawner import KubeSpawner
        from traitlets import Unicode
        from tornado import gen
        import z2jh
        import aiohttp

        # for SIS courses
        hosted_domain = 'berkeley.edu'
        course_profile_tmpl = '/srv/jupyterhub/profiles.d/{}-{}.txt'

        def memparse(val):
          '''Parse memory for relative comparisons.'''
          if type(val) != str or len(val) == 0: return val
          mem = int(val.upper()[0:-1])
          unit = val[-1]
          n = {'B':0, 'K':1, 'M':2, 'G':3}[unit]
          return mem * 1024**n

        def mem_cmp(a, b):
          '''Compare memory values.'''
          x = memparse(a) ; y = memparse(b)
          return (x > y) - (x < y)

        # for SIS courses
        def course_profile_filename(course, constituent):
          return course_profile_tmpl.format(course, constituent)

        # for SIS courses
        def course_members(course, constituent, hd=None):
          '''Extracts usernames from files containing email addresses.'''
          members = []
          filename = course_profile_filename(course, constituent)
          if not os.path.exists(filename): return members
          with open(filename) as f:
            line = f.readline()
            while line != '':
              email = line.strip()
              if hd and email.endswith('@' + hd):
                members.append(email.split('@')[0])
              elif not hd:
                members.append(email)
              line = f.readline()
          return members

        def course_error_messages(courses):
          return map(lambda x: x.get('message', ''), courses['errors'])

        def course_filter(courses, enrollment_type, attr='id'):
          '''Filter course attributes by enrollment type.'''
          attrs = []
          for course in courses:
            if 'enrollments' not in course: continue
            for enrollment in course['enrollments']:
              if enrollment['type'] == enrollment_type:
                attrs.append(course[attr]); break
          return attrs

        class InvalidAccessToken(Exception): pass

        class CustomAttrSpawner(KubeSpawner):

          canvas_client_id = Unicode('', config=True,
            help="OAuth client id to refresh the access token."
          )
          canvas_client_secret = Unicode('', config=True,
            help="OAuth client secret to refresh the access token."
          )
          canvas_url = Unicode('', config=True,
            help="Canvas URL."
          )

          async def refresh_access_token(self, auth_state):
            '''Use the user's refresh token to get a new access token.'''
            url = f"{self.canvas_url}/login/oauth2/token"
            params = dict(
              grant_type = 'refresh_token',
              client_id = self.canvas_client_id,
              client_secret = self.canvas_client_secret,
              refresh_token = auth_state['refresh_token']
            )
            data = {}
            async with aiohttp.ClientSession() as session:
              async with session.post(url, params=params) as r:
                data = await r.json()
            auth_state['access_token'] = data['access_token']
            await self.user.save_auth_state(auth_state)
            return data['access_token']

          @lru_cache(maxsize=1024)
          async def get_canvas_courses(self, token, enrollment_type=None):
            '''Fetch a persons courses from Canvas.'''
            headers = dict(Authorization = f"Bearer {token}")
            params = {}
            if enrollment_type: params["enrollment_type"] = enrollment_type
            url = f"{self.canvas_url}/api/v1/courses"
            data = []
            async with aiohttp.ClientSession() as session:
              async with session.get(url, headers=headers, params=params) as r:
                data = await r.json()
                if r.status == 401: # unauthorized
                  if "Invalid access token." in course_error_messages(data):
                    raise InvalidAccessToken()
                elif r.status != 200:
                  raise Exception(f"error: {r.status} -- {r.text()}")
            return data

          @gen.coroutine
          def start(self):
            # custom.memory
            custom_memory = z2jh.get_config('custom.memory', {})
            for attr, users in custom_memory.items():
              if self.user.name in users:
                self.mem_limit = attr
                self.mem_guarantee = attr
                break

            # custom.profiles (SIS)
            custom_profiles = z2jh.get_config('custom.profiles', {})
            is_student = False ; is_instructor = False
            for course, profile_data in custom_profiles.items():
              students    = course_members(course, 'students',    hosted_domain)
              instructors = course_members(course, 'instructors', hosted_domain)
              is_student    |= (self.user.name in students)
              is_instructor |= (self.user.name in instructors)
              if is_student or is_instructor:
                self.log.warning(f'using profile {course}')
                self.volumes += profile_data.get('extraVolumes', [])
                self.volume_mounts += profile_data.get('extraVolumeMounts', [])
                # set new mem thresholds if specified are bigger than current
                if 'mem_limit' in profile_data and \
                mem_cmp(profile_data['mem_limit'], self.mem_limit) == 1:
                  self.mem_limit = profile_data['mem_limit']
                if 'mem_guarantee' in profile_data and \
                mem_cmp(profile_data['mem_guarantee'], self.mem_guarantee) == 1:
                  self.mem_guarantee = profile_data['mem_guarantee']

            # if the user is a student in any course specified by a profile,
            # they never get to be an admin
            if is_student:
              self.user.admin = False
            elif is_instructor:
              self.user.admin = True

            ## custom.canvas_courses
            # retrieve the user's enrollments from bcourses
            canvas_courses = []
            auth_state = yield self.user.get_auth_state()
            if auth_state and 'access_token' in auth_state:
              token = auth_state['access_token']
              # FIXME: check token expiration rather than using try/except
              try:
                canvas_courses = yield self.get_canvas_courses(token)
              except InvalidAccessToken as e:
                self.log.warning(f"got invalid access token")
                new_token = yield self.refresh_access_token(auth_state)
                canvas_courses = yield self.get_canvas_courses(new_token)
              except Exception as e:
                self.log.info("error getting canvas courses")
                self.log.info(str(e))
            student_courses = course_filter(canvas_courses, 'student') + \
                              course_filter(canvas_courses, 'observer')
            instructor_courses = course_filter(canvas_courses, 'ta') + \
                                 course_filter(canvas_courses, 'teacher')
            self.log.info(f"student_courses: {student_courses}")
            self.log.info(f"instructor_courses: {instructor_courses}")

            # set resource limits, add volumes, set/revoke admin based on
            # courses
            custom_canvas_courses = z2jh.get_config('custom.canvas_courses', {})
            is_canvas_student = False ; is_canvas_instructor = False
            for canvas_course_id, profile_data in custom_canvas_courses.items():
              self.log.warning(f'evaluating course id {canvas_course_id}')
              is_canvas_student    |= (int(canvas_course_id) in student_courses)
              is_canvas_instructor |= (int(canvas_course_id) in instructor_courses)

              if is_canvas_student or is_canvas_instructor:
                self.log.warning(f'using course {canvas_course_id}')
                self.volumes += profile_data.get('extraVolumes', [])
                self.volume_mounts += profile_data.get('extraVolumeMounts', [])
                # set new mem thresholds if specified are bigger than current
                if 'mem_limit' in profile_data and \
                  mem_cmp(profile_data['mem_limit'], self.mem_limit) == 1:
                    self.mem_limit = profile_data['mem_limit']
                if 'mem_guarantee' in profile_data and \
                  mem_cmp(profile_data['mem_guarantee'], self.mem_guarantee) == 1:
                    self.mem_guarantee = profile_data['mem_guarantee']
              else:
                self.log.warning(f'user not in any canvas course')

            # if the user is a student in any canvas course specified by a
            # profile, they never get to be an admin
            if is_canvas_student:
              self.user.admin = False
            elif is_canvas_instructor:
              self.user.admin = True

            # custom.admin
            custom_admin = z2jh.get_config('custom.admin', {})
            if custom_admin and self.user.admin:
              self.init_containers += custom_admin.get('initContainers', [])
              self.volume_mounts += custom_admin.get('extraVolumeMounts', [])

            return (yield super().start())

        c.JupyterHub.spawner_class = CustomAttrSpawner

        c.JupyterHub.extra_log_file = '/srv/jupyterhub/jupyterhub.log'

      02-lab-availability: |
        c.Spawner.cmd = ['jupyter-labhub']

      03-working-dir: |
        # Make sure working directory is ${HOME}
        # hubploy has a bug where it unconditionally puts workingdir to be /srv/repo
        c.KubeSpawner.working_dir = '/home/jovyan'
      05-prometheus: |
        # Allow unauthenticated prometheus requests
        # Otherwise our prometheus server can't get to these
        c.JupyterHub.authenticate_prometheus = False
